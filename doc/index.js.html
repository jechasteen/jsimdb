

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      index.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      jsldb
    </h3>

    
      <h3>
        Resources
      </h3>
      
    

    <h3>Modules</h3><ul><li id="relational-nav"><a href="module-relational.html">relational</a><ul class='methods'><li data-type="method" id="relational-connect-nav"><a href="module-relational.html#.connect">connect</a></li><li data-type="method" id="relational-create-nav"><a href="module-relational.html#.create">create</a></li><li data-type="method" id="relational-delete-nav"><a href="module-relational.html#.delete">delete</a></li><li data-type="method" id="relational-find-nav"><a href="module-relational.html#.find">find</a></li><li data-type="method" id="relational-findById-nav"><a href="module-relational.html#.findById">findById</a></li><li data-type="method" id="relational-insert-nav"><a href="module-relational.html#.insert">insert</a></li><li data-type="method" id="relational-save-nav"><a href="module-relational.html#.save">save</a></li><li data-type="method" id="relational-saveSync-nav"><a href="module-relational.html#.saveSync">saveSync</a></li><li data-type="method" id="relational-setFieldById-nav"><a href="module-relational.html#.setFieldById">setFieldById</a></li><li data-type="method" id="relational-tables-nav"><a href="module-relational.html#.tables">tables</a></li><li data-type="method" id="relational-findAll-nav"><a href="module-relational.html#~findAll">findAll</a></li><li data-type="method" id="relational-verifyTables-nav"><a href="module-relational.html#~verifyTables">verifyTables</a></li></ul></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        index.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>/**
 * JavaScript Local Database, Relational
 * @module relational
 */

const fs = require('fs');
const path = require('path');
const baseDir = path.dirname(require.main.filename);
const { exec, execSync } = require('child_process');

const supportedTypes = ['number', 'string', 'date'];

// Holds the database in memory once we have either created or loaded from file.
let db = {};
// Holds the path to the database JSON file
db.path = undefined;
exports.path = function () {
    return db.path;
};
// Holds the autosave option passed at database creation, default false. Also set after connecting to an existing db
db.autosave = false;

const uuidQueue = (function () {
    const uuids = [];

    function handleOutput(err, stdout, stderr) {
        if (err) {
            console.log(err);
        }
        uuids.push(stdout.replace('\n', ''));
    }

    // TODO: Maybe this should be set via process.env?
    for (var i = 0; i &lt; 2; i++)
        uuids.push(execSync('uuidgen', { encoding: 'utf8' }).replace('\n', ''));

    return {
        get: function () {
            exec('uuidgen', handleOutput);
            return uuids.shift();
        },
    };
})();

/**
 * Checks the fields object for errors. If successful, the first parameter passed will be true, and the second will contain
 * a verified object. If it fails, it will return false as the first parameter, and the failed type text as a string.
 * Note: this function was intended to be called when a new database is created.
 * @param {object} unverifiedTables - A schema object used to create and verify db entries. This object is passed to create()
 * @param {function} cb - Function has the arguments (result: boolean, [failedType: string || passedTable: object])
 */
const verifyTables = (unverifiedTables, cb) => {
    const tables = [];

    for (let key in unverifiedTables) {
        tables.push(key);
    }

    tables.forEach((t) => {
        let curTable = unverifiedTables[t];
        for (let k in curTable) {
            const s = curTable[k].type.split(' ');
            const f = curTable[k];
            if (s.length === 1) {
                // type is basic
                if (supportedTypes.indexOf(f.type) &lt; 0) {
                    cb(false, f.type);
                } else {
                    continue;
                }
            } else if (s.length === 2) {
                // either "array ${type}" or "id ${table}"
                if (s[0] === 'id') {
                    if (tables.indexOf(s[1]) &lt; 0) {
                        return cb(false, f.type);
                    } else {
                        continue;
                    }
                } else if (s[0] === 'array') {
                    if (supportedTypes.indexOf(s[1]) &lt; 0) {
                        return cb(false, f.type);
                    } else {
                        continue;
                    }
                } else {
                    continue;
                }
            } else if (s.length === 3) {
                // "array id ${table}"
                if (tables.indexOf(s[2]) &lt; 0) {
                    cb(false, f.type);
                } else {
                    continue;
                }
            }
        }
    });

    cb(true, unverifiedTables);
};

/**
 * Initialize a new database.
 * This should be done with a new require() call for each database to be created.
 * @example
 * let db1 = require('jsldb')
 * db1.create('db1', db1schema, true);
 * let db2 = require('jsldb');
 * db2.create('db2, db2schema, false);
 * @param {string} name - The name of the new database
 * @param {Object} schema - A [tables]{@link docs/tables} schema object
 * @param {boolean} autosave - Whether to save automatically at creation and on changes, default false
 * @throws if the database given already exists, or if verify tables returns a check error.
 * @returns {boolean} - true if the database creation completed successfully. Undefined otherwise.
 */
exports.create = (name, schema, autosave = false) => {
    db.path = path.join(baseDir, `${name}.db.json`);
    const dbFilename = name + '.db.json';
    if (fs.existsSync(db.path)) {
        throw new Error(`Database ${name} already exists`);
    } else {
        db.autosave = autosave;
        verifyTables(schema, (res, data) => {
            if (!res) {
                throw new Error(
                    `Type given, ${data}, does not conform to a supported type.`
                );
            } else {
                db.schemas = data;
                db.tables = {};
                for (let key in data) {
                    db.schemas[key].count = 0;
                    db.tables[key] = {};
                }
            }
        });
    }
    return true;
};

/**
 * Connect to an existing database. Function expects just the "name" of the database as an abbreviation of the
 * filename name.db.json which this function will attempt to load.
 * @example
 * let db = require('jsldb');
 * db.connect('db');
 * @param {string} name - The name of the database to be loaded
 * @throws if the database given does not exist
 */
exports.connect = (name) => {
    db.path = path.join(baseDir, `${name}.db.json`);
    console.log('PATH', db.path);
    if (fs.existsSync(db.path)) {
        try {
            db = JSON.parse(fs.readFileSync(db.path));
            if (db.path === db.path) {
                return true;
            } else {
                return false;
            }
        } catch (e) {
            console.log(`Failed to load db from ${db.path}: ${e}`);
        }
    } else {
        throw new Error(`Database ${name} does not exist`);
    }
};

const checkField = (type, value) => {
    const valid = {
        number: (val) => {
            return typeof val === 'number';
        },
        string: (val) => {
            return typeof val === 'string';
        },
        date: (val) => {
            return val instanceof Date;
        },
    };

    const s = type.split(' ');

    if (!type || !value) {
        return false; // we know by the point this function is called values must exist for both parameters
    }

    if (s.length === 1) {
        // Simple type
        if (valid[type] &amp;&amp; valid[type](value)) return true;
        else return false;
    } else if (
        s[0] === 'array' &amp;&amp;
        s[1] !== 'id' &amp;&amp;
        supportedTypes.indexOf(s[1]) >= 0
    ) {
        if (value.length == 0) return true;
        // s[0] = 'array', s[1] 'type'
        const memberType = s[1];
        try {
            value.forEach((v) => {
                if (!valid[memberType](v)) {
                    return false;
                }
            });
            return true;
        } catch (e) {
            return false;
        }
    } else if (s[0] === 'array' &amp;&amp; s[1] === 'id') {
        // s[0] = 'array', s[1] = 'id', s[2] = 'table'
        if (!db.tables[s[2]]) {
            throw new Error(`Referenced table ${s[2]} does not exist.`);
        } else {
            if (value instanceof Array) {
                value.forEach((v) => {
                    if (!db.tables[s[2]][value]) {
                        return false;
                    }
                });
                return true;
            } else {
                // single value
                if (!db[s[2][value]]) {
                    return false;
                } else {
                    return true;
                }
            }
        }
    } else if (s[0] === 'id') {
        if (!db.tables[s[1]]) {
            throw new Error(`Referenced table ${s[1]} does not exist.`);
        } else {
            if (db.tables[s[1]][value]) {
                return true;
            }
        }
    } else {
        return false;
    }
};

/**
 * Add a new entry to a table.
 * The `_id` is a UUID and is created automatically.
 * @param {string} table - The name of the table to add to.
 * @param {Object} entry - An object that conforms to the schema specified in the tables object
 * @param {function} cb - Callback function. An error only if the check failed, or false first parameter and the newly created entry as the second.
 * @returns {boolean} - The result of the insertion operation. A check error if the check failed, or false if not.
 * @throws if the type check fails.
 */
exports.insert = (table, entry, cb = () => {}) => {
    const schema = db.schemas[table];

    for (let k in entry) {
        if (!checkField(schema[k].type, entry[k])) {
            console.log(`failed schema`);
            throw new Error(`Field Check failed for table ${table}, key ${k} value ${entry[k]}`);
        } else {
            continue;
        }
    }

    const id = uuidQueue.get();
    db.tables[table][id] = entry;
    db.tables[table][id]._id = id;

    if (db.autosave) {
        exports.save();
    }

    cb(true, db.tables[table][id]);
    return false;
};

/**
 * Overwrite the value for an existing field in the entry matching id.
 * @param {string} table - The table to be searched
 * @param {number} id - The id to be selected
 * @param {string} field - The field to be overwritten
 * @param {any} value - The value to be written. Must conform to schema.
 * @param {function} cb - A callback to be run after the set operation. The first parameter is success/failure. The second is the table entry written or null.
 * @returns {boolean} - The result of the set operation.
 */
exports.setFieldById = (table, id, field, value, cb = () => {}) => {
    // TODO: The callback has a pointless first parameter because it's being reserved
    //       for an error object in the future. Maybe some other value.
    if (checkField(db.schemas[table][field].type, value)) {
        if (db.tables[table].hasOwnProperty(id)) {
            db.tables[table][id][field] = value;
            cb(true, db.tables[table][id]);
        } else {
            console.log(`${id} does not exist in ${table}.`);
            cb(false, null);
        }
        if (db.autosave) {
            exports.save();
        }
        return true;
    } else {
        cb(false, null);
        return false;
    }
};

/**
 * Delete an entry by id.
 * @param {string} table - The table to be targeted
 * @param {number} id - The id of the entry to be deleted
 * @param {callback} cb - A callback function passed the deletion result and the id that was deleted
 */
exports.delete = (table, id, cb = () => {}) => {
    let result = delete db.tables[table][id];
    if (result) {
        cb(true, id);
    } else {
        cb(false, id);
    }
    if (db.autosave) {
        exports.save();
    }
};

/**
 * Fetch an entry by its id
 * @param {string} table - The table to be targeted
 * @param {number} id - The id of the entry to be retrieved
 * @param {function} cb - Callback function. First parameter is the result of the operation (true|false), second is
 * the entry that was retrieved
 * @returns {object} - The object which was found, or, if not found, undefined;
 */
exports.findById = (table, id, cb = () => {}) => {
    if (typeof cb !== 'function')
        throw new Error('Callback parameter to findById does not have type function.');
    const found = db.tables[table][parseInt(id)];
    if (found) {
        cb(true, found);
    } else {
        cb(false, id);
    }
    return found;
};

/**
 * Fetch the whole tables object
 * @param {function} cb - Callback function passed the full database object as a parameter
 * @returns {Object} - The full database object
 */
exports.tables = (cb) => {
    if (typeof cb === 'function') {
        cb(true, db.tables);
    }

    return db.tables;
};

db.fileExists = false;

function duplicateFileIfExists() {
    if (db.fileExists || fs.existsSync(db.path)) {
        fs.copyFileSync(db.path, path.join(db.path + '.old'));
    }
}

/**
 * Asynchronously write the database object in memory to file
 * @async
 * @param {function} cb An optional callback with one parameter (error?) that runs after the write operation.
 */
exports.save = function (cb) {
    duplicateFileIfExists();

    const dbJSON = JSON.stringify(db);
    if (typeof cb === 'function') {
        fs.writeFile(db.path, dbJSON, { encoding: 'utf8' }, cb);
        db.fileExists = fs.existsSync(db.path);
    } else {
        fs.writeFile(db.path, dbJSON, { encoding: 'utf8' }, () => {
            if (err) throw new Error(`Failed to save ${db.path}: err`);
            else {
                console.log(`Sucessfully saved ${db.path}`);
                db.fileExists = fs.existsSync(db.path);
            }
        });
    }
};

/**
 * Synchronously write the database object in memory to file
 * @returns {boolean} - The result of the operation.
 */

exports.saveSync = function () {
    duplicateFileIfExists();

    const dbJSON = JSON.stringify(db);
    fs.writeFileSync(db.path, dbJSON, { encoding: 'utf8' });
    if ((db.fileExists = fs.existsSync(db.path))) {
        console.log(`Successfully wrote ${db.path}`);
        return true;
    } else {
        console.log(`Failed to write ${db.path}`);
        return false;
    }
};

/**
 * Find all items in a table with given field matching value.
 * @example
 * let jonses = db.findAll('people', 'firstname', 'Jon');
 * jonses.forEach( (jon) => {
 *     console.log(`${jon.firstname} ${jon.lastname} is a jerk.`);
 * }); 
 * @param {string} table - The name of the table to be searched
 * @param {field} field - The field to find
 * @param {value} value - The value that must match
 * @returns {Object[]} - All matching objects
 */
function findAll(table, field, value) {
    let ret = [];
    for (key in table) {
        if (table[key][field] === value) {
            ret.push(table[key]);
        }
    }
    return ret;
}

/**
 * Query a table using query object. Finds ALL matching entries
 * The currently supported query type is `fieldName: 'valueToMatch'`
 * Caveat: does not exactly support `date: [Date object]`
 * @example
 * let james = db.find('people', { name: "Jame" });
 * james.forEach( (jame) => {
 *     console.log(`${jame.firstname} ${jame.lastname} has a great head of hair.`);
 * });
 * @param {string} tableName - The name of the table to be queried
 * @param {object} query - An object composed of the `field: value` pairs to be matched
 * @param {function} cb - A callback. If the query was successful (even if the results are empty), the first parameter will be true, if there was an error in the query it will be false.
 * the second parameter will be the found entries as an array (or undefined if none), or if there was an error a string describing the error.
 */
exports.find = (tableName, query, cb) => {
    if (query === {}) {
        cb(db.tables[tableName]);
    }

    const fields = (() => {
        let f = [];
        for (let key in db.schemas[tableName]) {
            f.push(key);
        }
        return f;
    })();

    for (let key in query) {
        if (fields.indexOf(key) > -1) {
            const results = findAll(db.tables[tableName], key, query[key]);
            if (results.length > 0) {
                cb(true, results);
            } else {
                cb(true, undefined);
            }
        } else {
            cb(
                false,
                `Query table name does not exist, table: ${tableName}, field ${key}`
            );
        }
    }
};
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
