

<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
      relational.js - Documentation
  </title>

  <link href="https://www.braintreepayments.com/images/favicon-ccda0b14.png" rel="icon" type="image/png">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>

  <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
  <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  
  <link type="text/css" rel="stylesheet" href="styles/collapse.css">
  

  

  <!-- start Mixpanel -->
  <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments,
  0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" ");
  for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]);
  mixpanel.init("1919205b2da72e4da3b9b6639b444d59");</script>
  <!-- end Mixpanel -->
</head>

<body>
  <svg style="display: none;">
    <defs>
      <symbol id="linkIcon" fill="#706d77" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 0h24v24H0z" fill="none"/>
          <path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
      </symbol>
    </defs>
  </svg>

  <input type="checkbox" id="nav-trigger" class="nav-trigger" />
  <label for="nav-trigger" class="navicon-button x">
    <div class="navicon"></div>
  </label>

  <label for="nav-trigger" class="overlay"></label>

  <div class="top-nav-wrapper">
    <ul>
      <li >
        <a href="index.html">
          
            <svg fill="#6D6D6D" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
              <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
              <path d="M0 0h24v24H0z" fill="none"/>
            </svg>
          
          
        </a>
      </li>

      

    </ul>
  </div>

  <nav>
    <h3 class="reference-title">
      jsldb
    </h3>

    
      <h3>
        Resources
      </h3>
      
        <a href="https://en.wikipedia.org/wiki/Relational_database">Wikipedia</a>
      
    

    <h3>Modules</h3><ul><li id="relational-nav"><a href="module-relational.html">relational</a><ul class='methods'><li data-type="method" id="relational-deleteById-nav"><a href="module-relational.html#~deleteById">deleteById</a></li><li data-type="method" id="relational-find-nav"><a href="module-relational.html#~find">find</a></li><li data-type="method" id="relational-findAll-nav"><a href="module-relational.html#~findAll">findAll</a></li><li data-type="method" id="relational-findAny-nav"><a href="module-relational.html#~findAny">findAny</a></li><li data-type="method" id="relational-findById-nav"><a href="module-relational.html#~findById">findById</a></li><li data-type="method" id="relational-getAllEntries-nav"><a href="module-relational.html#~getAllEntries">getAllEntries</a></li><li data-type="method" id="relational-insert-nav"><a href="module-relational.html#~insert">insert</a></li><li data-type="method" id="relational-save-nav"><a href="module-relational.html#~save">save</a></li><li data-type="method" id="relational-saveSync-nav"><a href="module-relational.html#~saveSync">saveSync</a></li><li data-type="method" id="relational-setFieldById-nav"><a href="module-relational.html#~setFieldById">setFieldById</a></li></ul></li></ul><h3 id="global-nav">Global</h3><ul><li><a href="global.html#Query">Query</a></li></ul>
  </nav>

  <div id="main">
    
      <h1 class="page-title">
        relational.js
      </h1>
    

    
      

<section>
  <article>
    <pre class="prettyprint source linenums"><code>const fs = require('fs')
const path = require('path')
const Query = require('./query')
const baseDir = path.dirname(require.main.filename)

// Allows us to see if a find operation has any results
if (!Object.size) {
    Object.size = function (obj) {
        var size = 0; var key
        for (key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) size++
        }
        return size
    }
}

/**
 * @module relational
 * @example
 * let jsldb = require('jsldb').relational
 * let db1 = jsldb('db1', db1schema)
 * let db2 = jsldb('db2, db2schema);
 * @param {string} name - The database's name. Must be unique.
 * @param {schema} schema - A Schema object that describes the table requirements.
 * @param {Object} options - Database optionals
 */
module.exports = function (name, schema, options) {
    const supportedTypes = ['number', 'string', 'date']
    let db = {}
    db.path = undefined
    setPath()
    if (fs.existsSync(db.path)) {
        connect()
    } else {
        create()
    }

    // Borrowed from faker sources because it's a fabulous method for javascript
    // https://github.com/Marak/faker.js/blob/master/lib/random.js
    const getUUID = function () {
        var RFC4122_TEMPLATE = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
        var replacePlaceholders = function (placeholder) {
            var random = Math.round(Math.random() * 15)
            var value = placeholder === 'x' ? random : (random &amp; 0x3 | 0x8)
            return value.toString(16)
        }
        return RFC4122_TEMPLATE.replace(/[xy]/g, replacePlaceholders)
    }

    /**
     * Check the value against the given type
     * @private
     * @param {string} type - The type to be checked against
     * @param {any} value - The value to check the type of
     * @return {boolean | Error} - True if check passed, false if it failed. Check for instancof Error with its output!
     */
    function checkField (type, value) {
        const validate = {
            number: (val) => {
                return typeof val === 'number'
            },
            string: (val) => {
                return typeof val === 'string'
            },
            date: (val) => {
                return val instanceof Date
            }
        }

        if (!type || !value) {
            return false
        }

        const s = type.split(' ')

        if (s.length === 1) {
            // Simple type
            if (validate[type] &amp;&amp; validate[type](value)) return true
            else return false
        } else if (
            s[0] === 'array' &amp;&amp;
            s[1] !== 'id' &amp;&amp;
            supportedTypes.indexOf(s[1]) >= 0
        ) {
            // s[0] = 'array', s[1] 'type'
            if (value.length === 0) return true
            if (!value) return true
            const type = s[1]
            try {
                value.forEach((v) => {
                    if (!validate[type](v)) {
                        return false
                    }
                })
                return true
            } catch (e) {
                return false
            }
        } else if (s[0] === 'array' &amp;&amp; s[1] === 'id') {
            // s[0] = 'array', s[1] = 'id', s[2] = 'tableName'
            if (!db.tables[s[2]]) {
                return new Error(`Referenced table ${s[2]} does not exist.`)
            } else {
                if (value instanceof Array) {
                    value.forEach((v) => {
                        if (!db.tables[s[2]][value]) {
                            return false
                        }
                    })
                    return true
                } else {
                    // single value
                    if (!db[s[2][value]]) {
                        return false
                    } else {
                        return true
                    }
                }
            }
        } else if (s[0] === 'id') {
            if (!value) return true
            if (!db.tables[s[1]]) {
                return new Error(`Referenced table ${s[1]} does not exist.`)
            } else if (!db.tables[s[1]][value]) {
                return new Error(`Referenced entry ${s[1]}:${value} does not exist`)
            } else if (db.tables[s[1]][value]) {
                return true
            }
        }
    }

    /**
     * Load an existing database file
     * @private
     * @throws if the database given does not exist
     */
    function connect () {
        setPath()
        if (fs.existsSync(db.path)) {
            try {
                db = JSON.parse(fs.readFileSync(db.path))
                if (db.path) {
                    return true
                } else {
                    return false
                }
            } catch (e) {
                throw new Error(`Failed to load db from ${db.path}: ${e}`)
            }
        } else {
            throw new Error(`Database ${name} does not exist`)
        }
    }

    /**
     * Initialize a new database.
     * This should be done with a new require() call for each database to be created.
     * @private
     * @throws if the database given already exists, or if table verification returns a check error.
     * @returns {boolean} - true if the database creation completed successfully. Undefined otherwise.
     */
    function create () {
        setPath()
        if (fs.existsSync(db.path)) {
            throw new Error(`Database ${name} already exists`)
        } else {
            verifyTables(schema, (err, data) => {
                if (err) {
                    throw err
                } else {
                    db.schemas = data
                    db.tables = {}
                    for (const key in data) {
                        db.tables[key] = {}
                    }
                }
            })
        }
        return true
    }

    /**
     * Delete an entry by id.
     * @instance
     * @param {string} table - The table to be targeted
     * @param {number} id - The id of the entry to be deleted
     * @param {callback} cb - A callback function (error?)
     */
    function deleteById (table, id, cb = () => {}) {
        if (Object.prototype.hasOwnProperty.call(db.tables[table], id)) {
            delete db.tables[table][id]
            cb(null)
        } else {
            cb(new Error(`Table has no entry with id ${id}`))
        }
    }

    function duplicateFileIfExists () {
        if (fs.existsSync(db.path)) {
            fs.copyFileSync(db.path, path.join(db.path + '.old'))
        }
    }

    function search (table, field, matchFn, search) {
        const found = []
        for (var key in table) {
            const cur = table[key]
            if (typeof search === 'string' ||
                    typeof search === 'number') {
                if ((matchFn === 'eq' &amp;&amp; cur[field] === search) ||
                        (matchFn === 'gt' &amp;&amp; cur[field] > search) ||
                        (matchFn === 'lt' &amp;&amp; cur[field] &lt; search) ||
                        (matchFn === 'gte' &amp;&amp; cur[field] >= search) ||
                        (matchFn === 'lte' &amp;&amp; cur[field] &lt;= search) ||
                        (matchFn === 'contains' &amp;&amp; cur[field] instanceof Array &amp;&amp; cur[field].includes(search))) {
                    found.push(key)
                }
            } else if (matchFn === 'regex' &amp;&amp;
                    search instanceof RegExp &amp;&amp;
                    typeof cur[field] === 'string' &amp;&amp;
                    cur[field].match(search)) {
                found.push(key)
            }
        }
        return found
    }

    /**
     * Query a table using query object.
     * You can call any of the other functions using options.queryType.
     * If not specified, defaults to 'all' type search.
     * @tutorial queries
     * @instance
     * @param {string} table - The name of the table to be queried
     * @param {Query|Query[]} query - An array composed of objects with `key: value` pairs to be matched. An empty object `{}` results in the whole table being returned.
     * @param {Object} options - Search options
     * @param {boolean} options.caseSensitive - True for case sensitive search, default true
     * @param {number} options.n - Only for *N queries, the number of results to return
     * @param {string} options.queryType - The type of query to perform. One of: id, anyN, anyOne, all, one, n, any.
     * @param {function} cb - Callback function (error?, resultsObject)
     */
    function find (query, options, cb) {
        if (typeof options === 'function') cb = options
        if ((typeof options !== 'object' &amp;&amp; typeof options !== 'function') ||
            (typeof cb !== 'function' || !cb)) return null
        if (!options || !options.queryType) {
            if (!options) options = {}
        }
        if (!options.queryType) {
            options.queryType = 'all'
        }
        if (options.queryType === 'id' &amp;&amp; typeof query === 'string' &amp;&amp; typeof options === 'string') {
            return findById(query, options, cb)
        } else if (options.queryType === 'all') {
            return findAll(query, cb)
        } else {
            return null
        }
    }

    function execQuery (query, cb) {
        try {
            if (typeof cb !== 'function' &amp;&amp; cb !== undefined) {
                throw new TypeError('Second parameter to find* must be function type.')
            }
            const found = []
            if (query instanceof Query) {
                found.push(search(db.tables[query.table], query.field, query.fn, query.val))
            } else if (query instanceof Array) {
                for (var q in query) {
                    if (!query[q] || !(query[q] instanceof Query)) {
                        throw new Error('Queries must be instances of the Query object.')
                    }
                    found.push(search(db.tables[query[q].table], query[q].field, query[q].fn, query[q].val))
                }
            } else {
                throw new Error('Query parameter must be either an array of Query objects, or a single Query object.')
            }
            if (found.length === 0) return null
            else return found
        } catch (e) {
            console.err('Failed to parse query: ' + e.text)
            return null
        }
    }

    function convertEntryArrayToObject (query, ids) {
        const ret = {}
        for (var i in ids) {
            ret[ids[i]] = db.tables[query.table][ids[i]]
        }
        return Object.size(ret) === 0 ? null : ret
    }

    /**
     * Find all matching entries, using AND logic for multiple conditions
     * @param {Query|Query[]} query Query or Queries
     * @param {function} cb Callback (err, entries)
     * @returns {Object} The found entries or null, if not found
     */
    function findAll (query, cb) {
        const found = execQuery(query, cb)
        if (!found) return cb(null, null)

        let ret = {}
        if (found.length === 1) {
            ret = convertEntryArrayToObject(query, found[0])
            cb(null, ret)
            return ret
        } else if (found.length > 1) {
            const common = []
            while (found.length > 1) {
                for (var i in found[0]) {
                    for (var j in found[1]) {
                        if (found[0][i] === found[1][j] &amp;&amp; common.indexOf(found[0][i]) === -1) {
                            common.push(found[0][i])
                        }
                    }
                }
                found.shift()
                found[0] = common
            }
            ret = convertEntryArrayToObject(query[0], common)
            cb(null, ret)
            return ret
        } else {
            return cb(null, null)
        }
    }

    /**
     * Find all matching entries, using OR logic for multiple conditions
     * @param {Query|Query[]} query Query or Queries
     * @param {function} cb Callback (err, entries)
     * @returns {Object} The found entries or null, if not found
     */
    function findAny (query, cb) {
        const found = execQuery(query, cb)
        if (!found) return cb(null, null)

        let ret = {}
        if (found.length === 1) {
            ret = convertEntryArrayToObject(query, found[0])
            cb(null, ret)
            return ret
        } else if (found.length > 1) {
            const all = []
            while (found.length > 0) {
                for (var i in found[0]) {
                    if (all.indexOf(found[0][i] === -1)) {
                        all.push(found[0][i])
                    }
                }
                found.shift()
            }
            ret = convertEntryArrayToObject(query[0], all)
            cb(null, ret)
            return ret
        } else {
            return cb(null, null)
        }
    }

    /**
     * Fetch an entry by its id
     * @instance
     * @param {string} table - The table to be targeted
     * @param {number} id - The id of the entry to be retrieved
     * @param {function} cb - Callback function. (error?, foundEntry?)
     * @returns {object} - The object which was found, or, if not found, undefined;
     */
    function findById (table, id, cb = () => {}) {
        if (typeof cb !== 'function') { throw new Error('Callback parameter to findById does not have type function.') }
        const found = db.tables[table][id]
        if (found) {
            cb(null, found)
        } else {
            cb(new Error(`Entry (${table}:${id}) not found.`), id)
        }
        return found
    }

    /**
     * Get all entries in the named table
     * @instance
     * @param {string} table - The table name
     * @returns {Object} - All entries in the named table
     */
    function getAllEntries (table) {
        return db.tables[table]
    }

    /**
     * Add a new entry to a table.
     * The `_id` is a UUID and is created automatically.
     * @instance
     * @example
     * TODO
     * @param {string} table - The name of the table to add to.
     * @param {Object} entry - An object that conforms to the schema specified in the tables object
     * @param {function} cb - Callback function (error?, newEntry?)
     * @returns {boolean} - The result of the insertion operation. A check error if the check failed, or false if not.
     * @throws if the type check fails.
     */
    function insert (table, entry, cb = () => {}) {
        const schema = db.schemas[table]

        for (const k in entry) {
            if (!schema[k]) cb(new Error(`Schema key ${k} has no type`), null)
            const checkResult = checkField(schema[k].type, entry[k])
            if (checkResult instanceof Error) {
                cb(checkResult, null)
                return
            } else if (!checkResult) {
                cb(new Error(`Type check failed: table ${table}, field ${schema[k]}, value ${entry[k]}`), null)
            } else {
                continue
            }
        }

        const id = getUUID()
        db.tables[table][id] = entry
        db.tables[table][id]._id = id

        cb(null, db.tables[table][id])
        return false
    }

    /**
     * Asynchronously write the database object in memory to file
     * @instance @async
     * @param {function} cb An optional callback with one parameter (error?) that runs after the write operation.
     */
    function save (cb) {
        duplicateFileIfExists()

        const dbJSON = JSON.stringify(db)
        if (typeof cb === 'function') {
            fs.writeFile(db.path, dbJSON, { encoding: 'utf8' }, cb)
        } else {
            fs.writeFile(db.path, dbJSON, { encoding: 'utf8' }, (err) => {
                if (err) throw new Error(`Failed to save ${db.path}: err`)
            })
        }
    }

    /**
     * Synchronously write the database object in memory to file
     * @instance
     * @returns {boolean} - The result of the operation.
     */
    function saveSync () {
        duplicateFileIfExists()

        const dbJSON = JSON.stringify(db)
        fs.writeFileSync(db.path, dbJSON, { encoding: 'utf8' })
        if (fs.existsSync(db.path)) {
            return true
        } else {
            return false
        }
    }

    /**
     * Set the path member according to the name parameter
     * @private
     */
    function setPath () {
        db.path = path.join(baseDir, `${name}.db.json`)
    }

    /**
     * Overwrite the value for an existing field in the entry matching id.
     * @instance
     * @param {string} table - The table to be searched
     * @param {number} id - The id to be selected
     * @param {string} field - The field to be overwritten
     * @param {any} value - The value to be written. Must conform to schema.
     * @param {function} cb - A callback to be run after the set operation. (error?, changedEntry?)
     * @returns {boolean} - The result of the set operation.
     */
    function setFieldById (table, id, field, value, cb = () => {}) {
        if (checkField(db.schemas[table][field].type, value)) {
            if (Object.prototype.hasOwnProperty.call(db.tables[table], id)) {
                db.tables[table][id][field] = value
                cb(null, db.tables[table][id])
            } else {
                cb(new Error(`${id} does not exist in ${table}.`), null)
                return false
            }
            return true
        } else {
            cb(new Error(`Field type check failed: (Field: ${field}, Value: ${value}, Type: ${db.schemas[table][field].type})`), null)
            return false
        }
    }

    /**
     * Checks the fields object for errors. If successful, the first parameter passed will be true, and the second will contain
     * a verified object. If it fails, it will return false as the first parameter, and the failed type text as a string.
     * @private
     * @param {object} inputTables - A schema object used to create and verify db entries. This object is passed to create()
     * @param {function} cb - Function has the arguments (error?, verifiedTables?)
     */
    function verifyTables (inputTables, cb) {
        const tables = []
        const tableNames = []

        for (const key in inputTables) {
            tables.push(inputTables[key])
            tableNames.push(key)
        }

        tables.forEach((table) => {
            for (const key in table) {
                if (!table[key].type) {
                    cb(Error(`Table attribute '${key}' has undefined type`))
                }
                const s = table[key].type.split(' ')
                const f = table[key]
                if (s.length === 1) {
                    // type is basic
                    if (supportedTypes.indexOf(f.type) &lt; 0) {
                        cb(new Error(`Not a supported type: ${f.type}.`), null)
                    } else {
                        continue
                    }
                } else if (s.length === 2) {
                    // either "array ${type}" or "id ${table}"
                    if (s[0] === 'id') {
                        if (tableNames.indexOf(s[1]) &lt; 0) {
                            return cb(new Error(`Table ${s[1]} does not exist.`), null)
                        } else {
                            continue
                        }
                    } else if (s[0] === 'array') {
                        if (supportedTypes.indexOf(s[1]) &lt; 0) {
                            return cb(new Error(`Not a supported type: ${s[1]}.`), null)
                        } else {
                            continue
                        }
                    } else {
                        continue
                    }
                } else if (s.length === 3) {
                    // "array id ${table}"
                    if (tableNames.indexOf(s[2]) &lt; 0) {
                        cb(new Error(`Table ${s[2]} does not exist.`), null)
                    } else {
                        continue
                    }
                }
            }
        })
        cb(null, inputTables)
    }

    return {
        deleteById: deleteById,
        find: find,
        findById: findById,
        findAll: findAll,
        findAny: findAny,
        // findAnyN: findAnyN,
        // findAnyOne: findAnyOne,
        // findN: findN,
        // findOne: findOne,
        getAllEntries: getAllEntries,
        insert: insert,
        path: function () { return db.path },
        save: save,
        saveSync: saveSync,
        setFieldById: setFieldById,
        tables: function () { return db.tables }
    }
}
</code></pre>
  </article>
</section>

    


  </div>

  <br class="clear">

  <footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.5</a>
  </footer>

  <script src="scripts/linenumber.js"></script>
  <script src="scripts/pagelocation.js"></script>

  

</body>
</html>
